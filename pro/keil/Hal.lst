C51 COMPILER V9.00   HAL                                                                   07/18/2016 22:42:55 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE HAL
OBJECT MODULE PLACED IN .\Hal.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\..\hal\Hal.c COMPACT BROWSE INCDIR(..\..\sys;..\..\app;..\..\hal) DEBUG 
                    -OBJECTEXTEND PRINT(.\Hal.lst) OBJECT(.\Hal.obj)

line level    source

   1          #include "stc89c5xrc.h"
   2          #include "Hal.h"
   3          
   4          #define HAL_PULSE_INFO_NUM 2
   5          
   6          HalPulseInfo_t g_pulseConfig[HAL_PULSE_INFO_NUM];
   7          static uint8_t g_pulseCount[2];
   8          static uint32_t g_timerCount = 0;
   9          static MotorStepOver_cb g_pluseStepOverCb = NULL;
  10          
  11          void HalGpioPinValueSet(uint8_t io, uint8_t val)
  12          {
  13   1          uint8_t port = (io & 0xf0) >> 4;
  14   1          uint8_t pin = io & 0x0f;
  15   1          uint8_t temp;
  16   1      
  17   1          switch(port)
  18   1          {
  19   2          case 0:
  20   2              temp = P0;
  21   2              if(val)
  22   2              {
  23   3                  temp |= 0x1 << pin;
  24   3              }
  25   2              else
  26   2              {
  27   3                  temp &= ~(0x1 << pin);
  28   3              }
  29   2              P0 = temp;
  30   2              break;
  31   2          case 1:
  32   2              temp = P1;
  33   2              if(val)
  34   2              {
  35   3                  temp |= 0x1 << pin;
  36   3              }
  37   2              else
  38   2              {
  39   3                  temp &= ~(0x1 << pin);
  40   3              }
  41   2              P1 = temp;
  42   2              break;
  43   2          case 2:
  44   2              temp = P2;
  45   2              if(val)
  46   2              {
  47   3                  temp |= 0x1 << pin;
  48   3              }
  49   2              else
  50   2              {
  51   3                  temp &= ~(0x1 << pin);
  52   3              }
  53   2              P2 = temp;
  54   2              break;
C51 COMPILER V9.00   HAL                                                                   07/18/2016 22:42:55 PAGE 2   

  55   2          case 3:
  56   2              temp = P3;
  57   2              if(val)
  58   2              {
  59   3                  temp |= 0x1 << pin;
  60   3              }
  61   2              else
  62   2              {
  63   3                  temp &= ~(0x1 << pin);
  64   3              }
  65   2              P3 = temp;
  66   2              break;
  67   2          case 4:
  68   2              temp = P4;
  69   2              if(val)
  70   2              {
  71   3                  temp |= 0x1 << pin;
  72   3              }
  73   2              else
  74   2              {
  75   3                  temp &= ~(0x1 << pin);
  76   3              }
  77   2              P4 = temp;
  78   2              break;
  79   2          default:
  80   2              break;
  81   2          }
  82   1      }
  83          
  84          uint8_t HalGpioPinValueGet(uint8_t io)
  85          {
  86   1          uint8_t val;
  87   1          uint8_t port = (io & 0xf0) >> 4;
  88   1          uint8_t pin = io & 0x0f;
  89   1      
  90   1          switch(port)
  91   1          {
  92   2          case 0:
  93   2              val = P0 & (0x1 << pin);
  94   2              break;
  95   2          case 1:
  96   2              val = P1 & (0x1 << pin);
  97   2              break;
  98   2          case 2:
  99   2              val = P2 & (0x1 << pin);
 100   2              break;
 101   2          case 3:
 102   2              val = P3 & (0x1 << pin);
 103   2              break;
 104   2          case 4:
 105   2              val = P4 & (0x1 << pin);
 106   2              break;
 107   2          default:
 108   2              break;
 109   2          }
 110   1          return val;
 111   1      }
 112          
 113          static void timerModeConfig(uint8_t timer0, uint8_t timer1)
 114          {
 115   1          uint8_t config = ((timer1 << 4) & 0xf0) + (timer0 & 0x0f);
 116   1          TMOD = config;
C51 COMPILER V9.00   HAL                                                                   07/18/2016 22:42:55 PAGE 3   

 117   1      }
 118          
 119          static void sysTimerInit(void)
 120          {
 121   1          TH0  = 0xfc;
 122   1          TL0  = 0x66;        //1ms
 123   1          TR0 = 1;
 124   1          ET0 = 1;
 125   1      }
 126          
 127          void Time0_Int() interrupt 1
 128          {
 129   1          TH0 = 0xfc;
 130   1          TL0 = 0x66;
 131   1          g_timerCount++;
 132   1      }
 133          
 134          void HalIRQEnableSet(bool enable)
 135          {
 136   1          EA = enable;
 137   1      }
 138          
 139          uint32_t HalSysTime(void)
 140          {
 141   1          return g_timerCount;
 142   1      }
 143          
 144          int8_t HalPulseInfoInit(uint8_t index, HalPulseInfo_t *info)
 145          {
 146   1          if(index >= HAL_PULSE_INFO_NUM)
 147   1          {
 148   2              return -1;
 149   2          }
 150   1          g_pulseConfig[index] = *info;
 151   1          HalGpioPinValueSet(info->enablePin, HAL_MOTOR_DISABLE_LEVEL);
 152   1          return 0;
 153   1      }
 154          
 155          HalPulseInfo_t *HalPulseInfoGet(uint8_t index)
 156          {
 157   1          return &g_pulseConfig[index];
 158   1      }
 159          
 160          int8_t HalPulseInfoSet(uint8_t index, MotorDirection_t dir, uint16_t count, bool enable)
 161          {
 162   1          if(index >= HAL_PULSE_INFO_NUM)
 163   1          {
 164   2              return -1;
 165   2          }
 166   1          g_pulseConfig[index].enable = enable;
 167   1          g_pulseConfig[index].val = HAL_MOTOR_CLK_DISABLE_LEVEL; //disable
 168   1          g_pulseConfig[index].count = count;
 169   1          g_pulseConfig[index].curNum = 0;
 170   1          g_pulseConfig[index].dir = dir;
 171   1          //  g_pulseConfig[index].cb = cb;
 172   1          if(enable)
 173   1          {
 174   2              if(dir == MOTOR_DIR_FORWARD)
 175   2              {
 176   3                  HalGpioPinValueSet(g_pulseConfig[index].dirPin, HAL_MOTOR_FORWARD_LEVEL); //forward
 177   3              }
 178   2              else
C51 COMPILER V9.00   HAL                                                                   07/18/2016 22:42:55 PAGE 4   

 179   2              {
 180   3                  HalGpioPinValueSet(g_pulseConfig[index].dirPin, HAL_MOTOR_BACKWARD_LEVEL); //backward
 181   3              }
 182   2              if(g_pulseConfig[index].enablePin != HAL_GPIO_INVALID)
 183   2              {
 184   3                  HalGpioPinValueSet(g_pulseConfig[index].enablePin, HAL_MOTOR_ENABLE_LEVEL);
 185   3              }
 186   2          }
 187   1          else
 188   1          {
 189   2              if(g_pulseConfig[index].enablePin != HAL_GPIO_INVALID)
 190   2              {
 191   3                  HalGpioPinValueSet(g_pulseConfig[index].enablePin, HAL_MOTOR_DISABLE_LEVEL);
 192   3              }
 193   2          }
 194   1          return 0;
 195   1      }
 196          
 197          /*
 198                  period: x ms
 199          */
 200          
 201          void HalPulseStart(uint32_t period, MotorStepOver_cb cb)
 202          {
 203   1          float count = 11059200 / 12 / (period * 1000);
 204   1          uint32_t timeCount = (uint32_t)count;
 205   1      
 206   1          g_pluseStepOverCb = cb;
 207   1      
 208   1          g_pulseCount[1] = (0xffff - timeCount) / 0xff;
 209   1          g_pulseCount[0] = (0xffff - timeCount) % 0xff;
 210   1          TH1  = g_pulseCount[1];
 211   1          TL1  = g_pulseCount[0];
 212   1          TR1 = 1; //enable timer 1
 213   1          ET1 = 1; //irq enable
 214   1      }
 215          
 216          void HalPulseStop(void)
 217          {
 218   1          ET1 = 0;
 219   1          TR1 = 0;
 220   1      }
 221          
 222          #define HAL_MOTOR_VALID_LEVEL 0x0
 223          
 224          void Time1_Int() interrupt 3
 225          {
 226   1          uint8_t i;
 227   1          for(i = 0; i < HAL_PULSE_INFO_NUM; i++)
 228   1          {
 229   2              if(g_pulseConfig[i].enable)
 230   2              {
 231   3                  if(g_pulseConfig[i].count != 0 && g_pulseConfig[i].curNum >= g_pulseConfig[i].count)
 232   3                  {
 233   4                      if(g_pluseStepOverCb != NULL)
 234   4                      {
 235   5                          g_pluseStepOverCb(i);
 236   5                      }
 237   4                  }
 238   3                  else
 239   3                  {
 240   4                      HalGpioPinValueSet(g_pulseConfig[i].ctrlPin, g_pulseConfig[i].val);
C51 COMPILER V9.00   HAL                                                                   07/18/2016 22:42:55 PAGE 5   

 241   4                      if(HAL_MOTOR_VALID_LEVEL == g_pulseConfig[i].val)
 242   4                      {
 243   5                          g_pulseConfig[i].curNum++;
 244   5                      }
 245   4                      g_pulseConfig[i].val = !g_pulseConfig[i].val;
 246   4                  }
 247   3              }
 248   2          }
 249   1          TH1  = g_pulseCount[1];
 250   1          TL1  = g_pulseCount[0];
 251   1      }
 252          
 253          uint8_t HalGetDevAddr(void)
 254          {
 255   1      #if HAL_USE_HARDWARE_ADDR
                  uint8_t addr = 0;
                  addr |= HalGpioPinValueGet(HAL_ADDR2_PIN) << 2;
                  addr |= HalGpioPinValueGet(HAL_ADDR1_PIN) << 1;
                  addr |= HalGpioPinValueGet(HAL_ADDR0_PIN);
                  return addr;
              #else
 262   1          return HAL_SOFTWARE_ADDR;
 263   1      #endif
 264   1      }
 265          
 266          static HalUartRecv_cb g_uartRecvCb = NULL;
 267          
 268          /*
 269          * serial init function, baudrate 9600bps
 270          * @param[in] serial receive callback func.
 271          */
 272          void HalUartInit(HalUartRecv_cb cb)
 273          {
 274   1          g_uartRecvCb = cb;
 275   1          HalIRQEnableSet(false);
 276   1          SCON = 0x50;
 277   1          T2CON = 0x34;
 278   1          RCAP2H = 0xff;
 279   1          RCAP2L = 0xdb;
 280   1          TH2 = RCAP2H;
 281   1          TL2 = RCAP2L;
 282   1          ES = 1;
 283   1          HalIRQEnableSet(true);
 284   1      }
 285          
 286          void HalUartSend(const uint8_t *dat, uint8_t len)
 287          {
 288   1          uint8_t i;
 289   1      
 290   1          for(i = 0; i < len; i++)
 291   1          {
 292   2              TI = 0;
 293   2              SBUF = dat[i];
 294   2              while(TI == 0);
 295   2              TI = 0;
 296   2          }
 297   1      }
 298          
 299          void uartIrq() interrupt 4
 300          {
 301   1          if(RI)
 302   1          {
C51 COMPILER V9.00   HAL                                                                   07/18/2016 22:42:55 PAGE 6   

 303   2              if(g_uartRecvCb != NULL)
 304   2              {
 305   3                  g_uartRecvCb(SBUF);
 306   3              }
 307   2              RI = 0;
 308   2          }
 309   1      }
 310          
 311          void HalInit(void)
 312          {
 313   1          timerModeConfig(1, 1);
 314   1          sysTimerInit();
 315   1          HalIRQEnableSet(true);
 316   1      }
 317          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1206    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     30      17
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
