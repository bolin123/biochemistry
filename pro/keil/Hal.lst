C51 COMPILER V9.00   HAL                                                                   07/12/2016 21:46:31 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE HAL
OBJECT MODULE PLACED IN .\Hal.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\..\hal\Hal.c COMPACT BROWSE INCDIR(..\..\sys;..\..\app;..\..\hal) DEBUG 
                    -OBJECTEXTEND PRINT(.\Hal.lst) OBJECT(.\Hal.obj)

line level    source

   1          #include "stc89c5xrc.h"
   2          #include "Hal.h"
   3          
   4          #define HAL_PULSE_INFO_NUM 2
   5          
   6          HalPulseInfo_t g_pulseConfig[HAL_PULSE_INFO_NUM];
   7          static uint8_t g_pulseCount[2];
   8          static uint32_t g_timerCount = 0;
   9          static MotorStepOver_cb g_pluseStepOverCb = NULL;
  10          
  11          void HalGpioPinValueSet(uint8_t io, uint8_t val)
  12          {
  13   1          uint8_t port = (io & 0xf0) >> 4;
  14   1          uint8_t pin = io & 0x0f;
  15   1          uint8_t temp;
  16   1      
  17   1          switch(port)
  18   1          {
  19   2          case 0:
  20   2              temp = P0;
  21   2              if(val)
  22   2              {
  23   3                  temp |= 0x1 << pin;
  24   3              }
  25   2              else
  26   2              {
  27   3                  temp &= ~(0x1 << pin);
  28   3              }
  29   2              P0 = temp;
  30   2              break;
  31   2          case 1:
  32   2              temp = P1;
  33   2              if(val)
  34   2              {
  35   3                  temp |= 0x1 << pin;
  36   3              }
  37   2              else
  38   2              {
  39   3                  temp &= ~(0x1 << pin);
  40   3              }
  41   2              P1 = temp;
  42   2              break;
  43   2          case 2:
  44   2              temp = P2;
  45   2              if(val)
  46   2              {
  47   3                  temp |= 0x1 << pin;
  48   3              }
  49   2              else
  50   2              {
  51   3                  temp &= ~(0x1 << pin);
  52   3              }
  53   2              P2 = temp;
  54   2              break;
C51 COMPILER V9.00   HAL                                                                   07/12/2016 21:46:31 PAGE 2   

  55   2          case 3:
  56   2              temp = P3;
  57   2              if(val)
  58   2              {
  59   3                  temp |= 0x1 << pin;
  60   3              }
  61   2              else
  62   2              {
  63   3                  temp &= ~(0x1 << pin);
  64   3              }
  65   2              P3 = temp;
  66   2              break;
  67   2          case 4:
  68   2              temp = P4;
  69   2              if(val)
  70   2              {
  71   3                  temp |= 0x1 << pin;
  72   3              }
  73   2              else
  74   2              {
  75   3                  temp &= ~(0x1 << pin);
  76   3              }
  77   2              P4 = temp;
  78   2              break;
  79   2          default:
  80   2              break;
  81   2          }
  82   1      }
  83          
  84          uint8_t HalGpioPinValueGet(uint8_t io)
  85          {
  86   1          uint8_t val;
  87   1          uint8_t port = (io & 0xf0) >> 4;
  88   1          uint8_t pin = io & 0x0f;
  89   1      
  90   1          switch(port)
  91   1          {
  92   2          case 0:
  93   2              val = P0 & (0x1 << pin);
  94   2              break;
  95   2          case 1:
  96   2              val = P1 & (0x1 << pin);
  97   2              break;
  98   2          case 2:
  99   2              val = P2 & (0x1 << pin);
 100   2              break;
 101   2          case 3:
 102   2              val = P3 & (0x1 << pin);
 103   2              break;
 104   2          case 4:
 105   2              val = P4 & (0x1 << pin);
 106   2              break;
 107   2          default:
 108   2              break;
 109   2          }
 110   1          return val;
 111   1      }
 112          
 113          static void timerModeConfig(uint8_t timer0, uint8_t timer1)
 114          {
 115   1          uint8_t config = ((timer1 << 4) & 0xf0) + (timer0 & 0x0f);
 116   1          TMOD = config;
C51 COMPILER V9.00   HAL                                                                   07/12/2016 21:46:31 PAGE 3   

 117   1      }
 118          
 119          static void sysTimerInit(void)
 120          {
 121   1          TH0  = 0xfc;
 122   1          TL0  = 0x66;        //1ms
 123   1          TR0 = 1;
 124   1          ET0 = 1;
 125   1      }
 126          
 127          void Time0_Int() interrupt 1
 128          {
 129   1          TH0 = 0xfc;
 130   1          TL0 = 0x66;
 131   1          g_timerCount++;
 132   1      }
 133          
 134          void HalIRQEnableSet(bool enable)
 135          {
 136   1          EA = enable;
 137   1      }
 138          
 139          uint32_t HalSysTime(void)
 140          {
 141   1          return g_timerCount;
 142   1      }
 143          
 144          int8_t HalPulseInfoInit(uint8_t index, HalPulseInfo_t *info)
 145          {
 146   1          if(index >= HAL_PULSE_INFO_NUM)
 147   1          {
 148   2              return -1;
 149   2          }
 150   1          g_pulseConfig[index] = *info;
 151   1          return 0;
 152   1      }
 153          
 154          HalPulseInfo_t *HalPulseInfoGet(uint8_t index)
 155          {
 156   1          return &g_pulseConfig[index];
 157   1      }
 158          
 159          int8_t HalPulseInfoSet(uint8_t index, MotorDirection_t dir, uint8_t count, bool enable)
 160          {
 161   1          if(index >= HAL_PULSE_INFO_NUM)
 162   1          {
 163   2              return -1;
 164   2          }
 165   1          g_pulseConfig[index].enable = enable;
 166   1          g_pulseConfig[index].val = HAL_MOTOR_CLK_DISABLE_LEVEL; //disable
 167   1          g_pulseConfig[index].count = count;
 168   1          g_pulseConfig[index].curNum = 0;
 169   1          g_pulseConfig[index].dir = dir;
 170   1          //  g_pulseConfig[index].cb = cb;
 171   1          if(enable)
 172   1          {
 173   2              if(dir == MOTOR_DIR_FORWARD)
 174   2              {
 175   3                  HalGpioPinValueSet(g_pulseConfig[index].dirPin, HAL_MOTOR_FORWARD_LEVEL); //forward
 176   3              }
 177   2              else
 178   2              {
C51 COMPILER V9.00   HAL                                                                   07/12/2016 21:46:31 PAGE 4   

 179   3                  HalGpioPinValueSet(g_pulseConfig[index].dirPin, HAL_MOTOR_BACKWARD_LEVEL); //backward
 180   3              }
 181   2              if(g_pulseConfig[index].enablePin != HAL_GPIO_INVALID)
 182   2              {
 183   3                  HalGpioPinValueSet(g_pulseConfig[index].enablePin, HAL_MOTOR_ENABLE_LEVEL);
 184   3              }
 185   2          }
 186   1          else
 187   1          {
 188   2              if(g_pulseConfig[index].enablePin != HAL_GPIO_INVALID)
 189   2              {
 190   3                  HalGpioPinValueSet(g_pulseConfig[index].enablePin, HAL_MOTOR_DISABLE_LEVEL);
 191   3              }
 192   2          }
 193   1          return 0;
 194   1      }
 195          
 196          /*
 197                  period: x ms
 198          */
 199          
 200          void HalPulseStart(uint32_t period, MotorStepOver_cb cb)
 201          {
 202   1          float count = 11059200 / 12 / (period * 1000);
 203   1          uint32_t timeCount = (uint32_t)count;
 204   1      
 205   1          g_pluseStepOverCb = cb;
 206   1      
 207   1          g_pulseCount[1] = (0xffff - timeCount) / 0xff;
 208   1          g_pulseCount[0] = (0xffff - timeCount) % 0xff;
 209   1          TH1  = g_pulseCount[1];
 210   1          TL1  = g_pulseCount[0];
 211   1          TR1 = 1; //enable timer 1
 212   1          ET1 = 1; //irq enable
 213   1      }
 214          
 215          void HalPulseStop(void)
 216          {
 217   1          ET1 = 0;
 218   1          TR1 = 0;
 219   1      }
 220          
 221          #define HAL_MOTOR_VALID_LEVEL 0x0
 222          
 223          void Time1_Int() interrupt 3
 224          {
 225   1          uint8_t i;
 226   1          for(i = 0; i < HAL_PULSE_INFO_NUM; i++)
 227   1          {
 228   2              if(g_pulseConfig[i].enable)
 229   2              {
 230   3                  if(g_pulseConfig[i].count != 0 && g_pulseConfig[i].curNum >= g_pulseConfig[i].count)
 231   3                  {
 232   4                      if(g_pluseStepOverCb != NULL)
 233   4                      {
 234   5                          g_pluseStepOverCb(i);
 235   5                      }
 236   4                  }
 237   3                  else
 238   3                  {
 239   4                      HalGpioPinValueSet(g_pulseConfig[i].ctrlPin, g_pulseConfig[i].val);
 240   4                      if(HAL_MOTOR_VALID_LEVEL == g_pulseConfig[i].val)
C51 COMPILER V9.00   HAL                                                                   07/12/2016 21:46:31 PAGE 5   

 241   4                      {
 242   5                          g_pulseConfig[i].curNum++;
 243   5                      }
 244   4                      g_pulseConfig[i].val = !g_pulseConfig[i].val;
 245   4                  }
 246   3              }
 247   2          }
 248   1          TH1  = g_pulseCount[1];
 249   1          TL1  = g_pulseCount[0];
 250   1      }
 251          
 252          uint8_t HalGetDevAddr(void)
 253          {
 254   1      #if HAL_USE_HARDWARE_ADDR
                  uint8_t addr = 0;
                  addr |= HalGpioPinValueGet(HAL_ADDR2_PIN) << 2;
                  addr |= HalGpioPinValueGet(HAL_ADDR1_PIN) << 1;
                  addr |= HalGpioPinValueGet(HAL_ADDR0_PIN);
                  return addr;
              #else
 261   1          return HAL_SOFTWARE_ADDR;
 262   1      #endif
 263   1      }
 264          
 265          static HalUartRecv_cb g_uartRecvCb = NULL;
 266          
 267          /*
 268          * serial init function, baudrate 9600bps
 269          * @param[in] serial receive callback func.
 270          */
 271          void HalUartInit(HalUartRecv_cb cb)
 272          {
 273   1          g_uartRecvCb = cb;
 274   1          HalIRQEnableSet(false);
 275   1          SCON = 0x50;
 276   1          T2CON = 0x34;
 277   1          RCAP2H = 0xff;
 278   1          RCAP2L = 0xdb;
 279   1          TH2 = RCAP2H;
 280   1          TL2 = RCAP2L;
 281   1          ES = 1;
 282   1          HalIRQEnableSet(true);
 283   1      }
 284          
 285          void HalUartSend(const uint8_t *dat, uint8_t len)
 286          {
 287   1          uint8_t i;
 288   1      
 289   1          for(i = 0; i < len; i++)
 290   1          {
 291   2              TI = 0;
 292   2              SBUF = dat[i];
 293   2              while(TI == 0);
 294   2              TI = 0;
 295   2          }
 296   1      }
 297          
 298          void uartIrq() interrupt 4
 299          {
 300   1          if(RI)
 301   1          {
 302   2              if(g_uartRecvCb != NULL)
C51 COMPILER V9.00   HAL                                                                   07/12/2016 21:46:31 PAGE 6   

 303   2              {
 304   3                  g_uartRecvCb(SBUF);
 305   3              }
 306   2              RI = 0;
 307   2          }
 308   1      }
 309          
 310          void HalInit(void)
 311          {
 312   1          timerModeConfig(1, 1);
 313   1          sysTimerInit();
 314   1          HalIRQEnableSet(true);
 315   1      }
 316          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1144    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     26      13
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
