C51 COMPILER V9.00   HAL                                                                   06/04/2016 22:33:29 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE HAL
OBJECT MODULE PLACED IN .\Hal.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\..\hal\Hal.c COMPACT BROWSE INCDIR(..\..\sys;..\..\app;..\..\hal) DEBUG 
                    -OBJECTEXTEND PRINT(.\Hal.lst) OBJECT(.\Hal.obj)

line level    source

   1          #include "stc89c5xrc.h"
   2          #include "Hal.h"
   3          
   4          #define HAL_PULSE_INFO_NUM 2
   5          
   6          HalPulseInfo_t g_pulseConfig[HAL_PULSE_INFO_NUM];
   7          static uint8_t g_pulseCount[2];
   8          static uint32_t g_timerCount = 0;
   9          
  10          void HalGpioPinValueSet(uint8_t io, uint8_t val)
  11          {
  12   1          uint8_t port = (io & 0xf0) >> 4;
  13   1          uint8_t pin = io & 0x0f;
  14   1          uint8_t temp;
  15   1          
  16   1          switch(port)
  17   1          {
  18   2              case 0:
  19   2                  temp = P0;
  20   2                  if(val)
  21   2                  {
  22   3                      temp |= 0x1 << pin;
  23   3                  }
  24   2                  else
  25   2                  {
  26   3                      temp &= ~(0x1 << pin);
  27   3                  }
  28   2                  P0 = temp;
  29   2                  break;
  30   2              case 1:
  31   2                  temp = P1;
  32   2                  if(val)
  33   2                  {
  34   3                      temp |= 0x1 << pin;
  35   3                  }
  36   2                  else
  37   2                  {
  38   3                      temp &= ~(0x1 << pin);
  39   3                  }
  40   2                  P1 = temp;
  41   2                  break;
  42   2              case 2:
  43   2                  temp = P2;
  44   2                  if(val)
  45   2                  {
  46   3                      temp |= 0x1 << pin;
  47   3                  }
  48   2                  else
  49   2                  {
  50   3                      temp &= ~(0x1 << pin);
  51   3                  }
  52   2                  P2 = temp;
  53   2                  break;
  54   2              case 3:
C51 COMPILER V9.00   HAL                                                                   06/04/2016 22:33:29 PAGE 2   

  55   2                  temp = P3;
  56   2                  if(val)
  57   2                  {
  58   3                      temp |= 0x1 << pin;
  59   3                  }
  60   2                  else
  61   2                  {
  62   3                      temp &= ~(0x1 << pin);
  63   3                  }
  64   2                  P3 = temp;
  65   2                  break;
  66   2              case 4:
  67   2                  temp = P4;
  68   2                  if(val)
  69   2                  {
  70   3                      temp |= 0x1 << pin;
  71   3                  }
  72   2                  else
  73   2                  {
  74   3                      temp &= ~(0x1 << pin);
  75   3                  }
  76   2                  P4 = temp;
  77   2                  break;
  78   2              default:
  79   2                  break;
  80   2          }
  81   1      }
  82          
  83          uint8_t HalGpioPinValueGet(uint8_t io)
  84          {
  85   1          uint8_t val;
  86   1          uint8_t port = (io & 0xf0) >> 4;
  87   1          uint8_t pin = io & 0x0f;
  88   1          
  89   1          switch(port)
  90   1          {
  91   2              case 0:
  92   2                  val = P0 & (0x1 << pin);
  93   2                  break;
  94   2              case 1:
  95   2                  val = P1 & (0x1 << pin);
  96   2                  break;
  97   2              case 2:
  98   2                  val = P2 & (0x1 << pin);
  99   2                  break;
 100   2              case 3:
 101   2                  val = P3 & (0x1 << pin);
 102   2                  break;
 103   2              case 4:
 104   2                  val = P4 & (0x1 << pin);
 105   2                  break;
 106   2              default:
 107   2                  break;
 108   2          }
 109   1          return val;
 110   1      }
 111          
 112          static void timerModeConfig(uint8_t timer0, uint8_t timer1)
 113          {       
 114   1              uint8_t config = ((timer1 << 4) & 0xf0) + (timer0 & 0x0f);
 115   1              TMOD = config;
 116   1      }
C51 COMPILER V9.00   HAL                                                                   06/04/2016 22:33:29 PAGE 3   

 117          
 118          static void sysTimerInit(void)
 119          {
 120   1              TH0  = 0xfc;
 121   1              TL0  = 0x66;    //1ms
 122   1              TR0 = 1;
 123   1              ET0 = 1;
 124   1      }
 125          
 126          void Time0_Int() interrupt 1
 127          {
 128   1              TH0 = 0xfc;
 129   1              TL0 = 0x66;
 130   1              g_timerCount++;
 131   1      }
 132          
 133          void HalIRQEnableSet(bool enable)
 134          {       
 135   1          EA = enable;
 136   1      }
 137          
 138          uint32_t HalSysTime(void)
 139          {
 140   1          return g_timerCount;
 141   1      }
 142          
 143          int8_t HalPulseInfoInit(uint8_t index, HalPulseInfo_t *info)
 144          {       
 145   1              if(index >= HAL_PULSE_INFO_NUM)
 146   1              {
 147   2                      return -1;
 148   2              }
 149   1              g_pulseConfig[index] = *info;
 150   1              return 0;
 151   1      }
 152          
 153          HalPulseInfo_t * HalPulseInfoGet(uint8_t index)
 154          {
 155   1              return &g_pulseConfig[index];
 156   1      }
 157          
 158          int8_t HalPulseInfoSet(uint8_t index, MotorDirection_t dir, 
 159                  uint8_t count, bool enable, motorCountOver_cb cb)
 160          {
 161   1              if(index >= HAL_PULSE_INFO_NUM)
 162   1              {
 163   2                      return -1;
 164   2              }
 165   1              g_pulseConfig[index].enable = enable;
 166   1              g_pulseConfig[index].val = HAL_MOTOR_CLK_DISABLE_LEVEL; //disable
 167   1              g_pulseConfig[index].count = count;
 168   1              g_pulseConfig[index].curNum = 0;
 169   1              g_pulseConfig[index].dir = dir;
 170   1              g_pulseConfig[index].cb = cb;
 171   1              if(enable)
 172   1              {               
 173   2                      if(dir == MOTOR_DIR_FORWARD)
 174   2                      {
 175   3                              HalGpioPinValueSet(g_pulseConfig[index].dirPin, HAL_MOTOR_FORWARD_LEVEL); //forward
 176   3                      }
 177   2                      else
 178   2                      {
C51 COMPILER V9.00   HAL                                                                   06/04/2016 22:33:29 PAGE 4   

 179   3                              HalGpioPinValueSet(g_pulseConfig[index].dirPin, HAL_MOTOR_BACKWARD_LEVEL); //backward
 180   3                      }
 181   2                      if(g_pulseConfig[index].enablePin != HAL_GPIO_INVALID)
 182   2                      {
 183   3                              HalGpioPinValueSet(g_pulseConfig[index].enablePin, HAL_MOTOR_ENABLE_LEVEL);
 184   3                      }
 185   2              }
 186   1              else
 187   1              {
 188   2                      if(g_pulseConfig[index].enablePin != HAL_GPIO_INVALID)
 189   2                      {
 190   3                              HalGpioPinValueSet(g_pulseConfig[index].enablePin, HAL_MOTOR_DISABLE_LEVEL);
 191   3                      }
 192   2              }
 193   1          return 0;
 194   1      }
 195          
 196          /*
 197                  period: x ms
 198          */
 199          
 200          void HalPulseStart(uint32_t period)
 201          {
 202   1              float count = 11059200/12/(period*1000);
 203   1              uint32_t timeCount = (uint32_t)count;
 204   1      
 205   1              g_pulseCount[1] = (0xffff - timeCount)/0xff;
 206   1              g_pulseCount[0] = (0xffff - timeCount)%0xff;
 207   1              TH1  = g_pulseCount[1];
 208   1              TL1  = g_pulseCount[0];
 209   1              TR1 = 1; //enable timer 1
 210   1              ET1 = 1; //irq enable
 211   1      }
 212          
 213          void HalPulseStop(void)
 214          {
 215   1              ET1 = 0;
 216   1              TR1 = 0;
 217   1      }
 218          
 219          #define HAL_MOTOR_VALID_LEVEL 0x0
 220          
 221          void Time1_Int() interrupt 3
 222          {
 223   1              uint8_t i;
 224   1              for(i = 0; i < HAL_PULSE_INFO_NUM; i++)
 225   1              {
 226   2                      if(g_pulseConfig[i].enable)
 227   2                      {
 228   3                              if(g_pulseConfig[i].count != 0 && g_pulseConfig[i].curNum >= g_pulseConfig[i].count)
 229   3                              {
 230   4                                      if(g_pulseConfig[i].cb != NULL)
 231   4                                      {
 232   5                                              g_pulseConfig[i].cb(i);
 233   5                                      }
 234   4                              }
 235   3                              else
 236   3                              {
 237   4                                      HalGpioPinValueSet(g_pulseConfig[i].ctrlPin, g_pulseConfig[i].val);
 238   4                                      if(HAL_MOTOR_VALID_LEVEL == g_pulseConfig[i].val)
 239   4                                      {
 240   5                                              g_pulseConfig[i].curNum++;
C51 COMPILER V9.00   HAL                                                                   06/04/2016 22:33:29 PAGE 5   

 241   5                                      }
 242   4                                      g_pulseConfig[i].val = !g_pulseConfig[i].val;
 243   4                              }
 244   3                      }
 245   2              }
 246   1              TH1  = g_pulseCount[1];
 247   1              TL1  = g_pulseCount[0];
 248   1      }
 249          
 250          uint8_t HalGetDevAddr(void)
 251          {
 252   1      #if HAL_USE_HARDWARE_ADDR
                      uint8_t addr = 0;
                      addr |= HalGpioPinValueGet(HAL_ADDR2_PIN) << 2;
                      addr |= HalGpioPinValueGet(HAL_ADDR1_PIN) << 1;
                      addr |= HalGpioPinValueGet(HAL_ADDR0_PIN);
                      return addr;
              #else
 259   1              return HAL_SOFTWARE_ADDR;
 260   1      #endif
 261   1      }
 262          
 263          static HalUartRecv_cb g_uartRecvCb = NULL;
 264          
 265          void HalUartInit(HalUartRecv_cb cb)
 266          {
 267   1              g_uartRecvCb = cb;
 268   1          HalIRQEnableSet(false);
 269   1          SCON = 0x50;
 270   1          T2CON = 0x34;
 271   1          RCAP2H = 0xff;
 272   1          RCAP2L = 0xdb;
 273   1          TH2 = RCAP2H;
 274   1          TL2 = RCAP2L;
 275   1          ES = 1;
 276   1          HalIRQEnableSet(true);
 277   1      }
 278          
 279          void HalUartSend(const uint8_t *dat, uint8_t len)
 280          {
 281   1              uint8_t i;
 282   1      
 283   1              for(i = 0; i < len; i++)
 284   1              {
 285   2                      TI = 0;
 286   2                      SBUF = dat[i];
 287   2                      while(TI == 0);
 288   2                      TI = 0;
 289   2              }
 290   1      }
 291          
 292          void uartIrq() interrupt 4
 293          {
 294   1              if(RI)
 295   1          {
 296   2                      if(g_uartRecvCb != NULL)
 297   2                      {
 298   3                              g_uartRecvCb(SBUF);
 299   3                      }
 300   2              RI = 0;
 301   2          }
 302   1      }
C51 COMPILER V9.00   HAL                                                                   06/04/2016 22:33:29 PAGE 6   

 303          
 304          void HalInit(void)
 305          {
 306   1              timerModeConfig(1, 1);
 307   1          sysTimerInit();
 308   1              HalIRQEnableSet(true);
 309   1      }
 310          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1165    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     29      11
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
